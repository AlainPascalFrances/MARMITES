import numpy as np
from mbase import package

class mfdis(package):
    '''Discretization package class\n'''
    '''model: modflow object to which package is added, created with modflow( nlay, nrow, ncol, nper=1 )
    delr: column widths, scalar or array of length ncol
    delc: row widths, scalar or array of length nrow
    laycbd: flag that indicates if confining unit is present below layer, length nlay
    top: elevation of top of first layer, scalar or array of nrow,ncol
    botm: elevations of bottoms of layers, array of length nlay, or array of (nlay,nrow,ncol)
    steady=[True]: boolean indicating whether simulation of stress period is steady, scalar or array of length nper
    perlen=[1]: lengths of stress periods, scalar or array of length nper
    nstp=[1]: number of steps per stress period, scalar or array of length nper
    tsmult=[1]: time step multiplier, scalar or array of length nper
    itmuni: time units, default days (= 4)
    lenuni: length units, default meters (= 2)
    fname: filename between quotes
    '''
    def __init__(self, model, nrow, ncol, nlay, nper = 1, delr=1.0, delc=1.0, laycbd=1, top=1, botm=0, perlen=1, nstp=1, tsmult=1, steady=True, itmuni=4, lenuni=2, extension='dis', unitnumber=11):
        package.__init__(self, model, extension, 'DIS', unitnumber) # Call ancestor's init to set self.parent, extension, name and unit number
        self.url = 'dis.htm'
        self.nrow = nrow
        self.ncol = ncol
        self.nlay = nlay
        self.nper = nper
        # First create arrays so that they have the correct size
        self.delr = np.empty( self.ncol )
        self.delc = np.empty( self.nrow )
        self.laycbd = np.ones( self.nlay, 'int' )
        self.laycbd[-1] = 0 # bottom layer must be zero
        self.top = np.empty((self.nrow, self.ncol))
        self.botm = np.empty((self.nrow, self.ncol, self.nlay + sum(self.laycbd) ))
        self.perlen = np.empty(self.nper)
        self.nstp = np.empty(self.nper, 'int')
        self.tsmult = np.empty(self.nper)
        self.steady = np.empty(self.nper, 'bool')
        self.__thickness = np.empty(np.shape(self.botm))
        # Set values of all parameters
        self.heading = '# Discretization file for MODFLOW-2000, generated by Flopy.'
        self.assignarray( self.delr, delr )
        self.assignarray( self.delc, delc )
        self.assignarray( self.laycbd, laycbd )
        # reset laycbd of bottom to 0
        self.laycbd[-1] = 0
        # recompute size of self.botm
        self.botm = np.empty((self.nrow, self.ncol, self.nlay + sum(self.laycbd) ))
        self.assignarray( self.top, top)
        self.assignarray( self.botm, botm)
        if (not self.checklayerthickness()):
            print 'Warning: Cells with zero-layer thickness encountered!'
        self.assignarray( self.perlen, perlen )
        self.assignarray( self.nstp, nstp )
        self.assignarray( self.tsmult, tsmult )
        self.assignarray( self.steady, steady )
        assert (self.perlen.shape[0] == self.nstp.shape[0] == self.tsmult.shape[0] == self.steady.shape[0]), 'perlen, nstp, tsmult and steady all must have the same number of rows'
        self.itmuni = itmuni
        self.lenuni = lenuni
        self.parent.add_package(self)
    def checklayerthickness(self):
        return (self.get_thickness() > 0).all()
    def get_cell_volumes(self):
        vol = np.empty((self.nrow, self.ncol, self.nlay))
        for r in range(self.nrow):
            vol[r, :, :] = self.delc[r]
        for c in range(self.ncol):
            vol[:, c, :] = vol[:, c, :] * self.delr[c]
        for l in range(self.nlay):
            vol[:, :, l] = vol[:, :, l] * self.get_thickness()[:, :, l]
        return vol
    def get_node_coordinates(self):
        # In row direction
        y = np.empty((self.nrow))
        for r in range(self.nrow):
            if (r == 0):
                y[r] = self.delc[r] / 2.
            else:
                y[r] = y[r - 1] + self.delc[r]
        # In column direction
        x = np.empty((self.ncol))
        for c in range(self.ncol):
            if (c == 0):
                x[c] = self.delr[c] / 2.
            else:
                x[c] = x[c - 1] + self.delr[c]
        # In layer direction
        z = np.empty((self.nrow, self.ncol, self.nlay))
        l = 0
        for l in range(self.nlay):
            if (l == 0):
                z[:, :, l] = (self.top + self.botm[:, :, l]) / 2.
            else:
                z[:, :, l] = (self.botm[:, :, l - 1] + self.botm[:, :, l]) / 2.
        return y, x, z
    def get_thickness(self):
        self.update_thickness()
        return self.__thickness
    thickness = property(get_thickness) # Read only property
    def read_from_cnf(self, cnf_file_name):
        try:
            f_cnf = open(cnf_file_name, 'r')

            # nlay, nrow, ncol
            line = f_cnf.readline()
            s = line.split()
            cnf_nlay = int(s[0])
            cnf_nrow = int(s[1])
            cnf_ncol = int(s[2])

            # ncol column widths delr[c]
            line = f_cnf.readline()
            cnf_delr = [float(s) for s in line.split()]

            # nrow row widths delc[r]
            line = f_cnf.readline()
            cnf_delc = [float(s) for s in line.split()]

            # nrow * ncol htop[r, c]
            line = f_cnf.readline()
            cnf_top = [float(s) for s in line.split()]
            cnf_top = np.reshape(cnf_top, (cnf_nrow, cnf_ncol))

            # nlay * nrow * ncol layer thickness dz[l, r, c]
            line = f_cnf.readline()
            cnf_dz = [float(s) for s in line.split()]
            cnf_dz = np.reshape(cnf_dz, (cnf_nlay, cnf_nrow, cnf_ncol))

            # cinact, cdry, not used here so commented
            '''line = f_cnf.readline()
            s = line.split()
            cinact = float(s[0])
            cdry = float(s[1])'''

            f_cnf.close()
        finally:
            self.nlay = cnf_nlay
            self.nrow = cnf_nrow
            self.ncol = cnf_ncol

            self.delr = np.empty( self.ncol )
            self.assignarray( self.delr, cnf_delr )

            self.delc = np.empty( self.nrow )
            self.assignarray( self.delc, cnf_delc )

            self.top = np.empty((self.nrow, self.ncol))
            self.assignarray( self.top, cnf_top)

            self.botm = np.empty((self.nrow, self.ncol, self.nlay + sum(self.laycbd) ))
            # First model layer
            self.botm[:, :, 0] = self.top - cnf_dz[0, :, :]
            # All other layers
            for l in range(1, self.nlay):
                self.botm[:, :, l] = self.botm[:, :, l - 1] - cnf_dz[l, :, :]
            self.update_thickness()
    def update_thickness(self):
        # Make sure that the thickness array has the same dimensions as the botm array
        if (self.__thickness.shape != self.botm.shape):
            self.__thickness = np.empty(np.shape(self.botm))
        # First model layer
        self.__thickness[:, :, 0] = self.top - self.botm[:, :, 0]
        # All other layers
        for l in range(1, self.nlay):
            self.__thickness[:, :, l] = self.botm[:, :, l - 1] - self.botm[:, :, l]
    def write_file(self):
        # Open file for writing
        f_dis = open(self.fn_path, 'w')
        # Item 0: heading
        f_dis.write('%s\n' % self.heading)
        # Item 1: NLAY, NROW, NCOL, NPER, ITMUNI, LENUNI
        f_dis.write('%10d%10d%10d%10d%10d%10d\n' % (self.nlay, self.nrow, self.ncol, self.nper, self.itmuni, self.lenuni))
        # Item 2: LAYCBD
        # Check if all items must/can be on 1 single line
        for l in range(0, self.nlay):
            f_dis.write('%3d' % (self.laycbd[l]))
        f_dis.write('\n')
        # Item 3: DELR
        self.parent.write_array(f_dis, self.delr, self.unit_number[0], True, 13, 5, 'DELR(NCOL)')
        # Item 4: DELC
        self.parent.write_array(f_dis, self.delc, self.unit_number[0], True, 13, 5, 'DELC(NROW)')
        # Item 5: Top(NCOL, NROW)
        self.parent.write_array(f_dis, self.top, self.unit_number[0], True, 13, 5, 'TOP OF SYSTEM')
        # Item 5: BOTM(NCOL, NROW)
        self.parent.write_array(f_dis, self.botm, self.unit_number[0], True, 13, 5, 'BOTTOM OF LAYER')
        # Item 6: NPER, NSTP, TSMULT, Ss/tr
        for t in range(self.nper):
            f_dis.write('%14f%14d%10f' % (self.perlen[t], self.nstp[t], self.tsmult[t]))
            if self.steady[t]:
                f_dis.write('%3s\n' % 'SS')
            else:
                f_dis.write('%3s\n' % 'TR')
        f_dis.close()
