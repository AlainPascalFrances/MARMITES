#from numpy import *
from mbase import basemodel, package
from mfbas import mfbas
from mfbcf import mfbcf
from mflpf import mflpf
from mfchd import mfchd
from mfdis import mfdis
from mfdrn import mfdrn
from mfevt import mfevt
from mfghb import mfghb
from mfpbc import mfpbc
from mfrch import mfrch
from mfriv import mfriv
from mfwel import mfwel
from mfoc import mfoc
from mfswi import mfswi
from mfpcg import mfpcg
from mfsip import mfsip
from mfsor import mfsor
import os

class mfglobal(package):
    'Global package class'
    def __init__(self, model, extension='glo'):
        package.__init__(self, model, extension, 'GLOBAL', 1) # Call ancestor's init to set self.parent, extension, name and unit number
        #self.parent.add_package(self) This package is not added to the base model so that it is not included in get_name_file_entries()
    def __repr__( self ):
        return 'Global package class'
    def write_file(self):
    	# Not implemented for global class
    	return

class mflist(package):
    'List package class'
    def __init__(self, model, extension='list', unitnumber=2):
        package.__init__(self, model, extension, 'LIST', unitnumber) # Call ancestor's init to set self.parent, extension, name and unit number
        #self.parent.add_package(self) This package is not added to the base model so that it is not included in get_name_file_entries()
    def __repr__( self ):
        return 'List package class'
    def write_file(self):
    	# Not implemented for list class
    	return

class modflow(basemodel):
    'MODFLOW base class'
    def __init__(self, modelname = 'modflowtest', namefile_ext = 'nam', version = 'mf2005', exe_name='mf2005.exe', listunit=2, model_ws = 'C:/temp'):
        basemodel.__init__(self, modelname, namefile_ext, exe_name, model_ws)
        self.heading = '# Name file for ' + version + ', generated by Flopy.'
        if version == 'mf2k':
            self.glo = mfglobal(self)
        self.lst = mflist(self, unitnumber=listunit)
        self.version = version  # So that we can do something different for mf2005
        '''self.__bcf = None
        self.__chd = None
        self.__dis = None
        self.__drn = None
        self.__evt = None
        self.__ghb = None
        self.__pbc = None
        self.__rch = None
        self.__riv = None
        self.__wel = None'''
    def __repr__( self ):
        nrow, ncol, nlay, nper = self.get_nrow_ncol_nlay_nper()
        return 'MODFLOW %d layer(s), %d row(s), %d column(s), %d stress period(s)' % ( nlay, nrow, ncol, nper)
    def get_nrow_ncol_nlay_nper(self):
        dis = self.get_package('DIS')
        if (dis):
            return dis.nrow, dis.ncol, dis.nlay, dis.nper
        else:
            return 0, 0, 0, 0
    '''def getbcf(self):
        if (self.__bcf == None):
            for p in (self.packagelist):
                if isinstance(p, mfbcf):
                    self.__bcf = p
        return self.__bcf
    def getchd(self):
        if (self.__chd == None):
            for p in (self.packagelist):
                if isinstance(p, mfchd):
                    self.__chd = p
        return self.__chd
    def getdis(self):
        if (self.__dis == None):
            for p in (self.packagelist):
                if isinstance(p, mfdis):
                    self.__dis = p
        return self.__dis
    def getdrn(self):
        if (self.__drn == None):
            for p in (self.packagelist):
                if isinstance(p, mfdrn):
                    self.__drn = p
        return self.__drn
    def getevt(self):
        if (self.__evt == None):
            for p in (self.packagelist):
                if isinstance(p, mfevt):
                    self.__evt = p
        return self.__evt
    def getghb(self):
        if (self.__ghb == None):
            for p in (self.packagelist):
                if isinstance(p, mfghb):
                    self.__ghb = p
        return self.__ghb
    def getpbc(self):
        if (self.__pbc == None):
            for p in (self.packagelist):
                if isinstance(p, mfpbc):
                    self.__pbc = p
        return self.__pbc
    def getrch(self):
        if (self.__rch == None):
            for p in (self.packagelist):
                if isinstance(p, mfrch):
                    self.__rch = p
        return self.__rch
    def getriv(self):
        if (self.__riv == None):
            for p in (self.packagelist):
                if isinstance(p, mfriv):
                    self.__riv = p
        return self.__riv
    def getwel(self):
        if (self.__wel == None):
            for p in (self.packagelist):
                if isinstance(p, mfwel):
                    self.__wel = p
        return self.__wel
    bcf = property(getbcf) # Property has no setter, so read-only
    chd = property(getchd) # Property has no setter, so read-only
    dis = property(getdis) # Property has no setter, so read-only
    drn = property(getdrn) # Property has no setter, so read-only
    evt = property(getevt) # Property has no setter, so read-only
    ghb = property(getghb) # Property has no setter, so read-only
    pbc = property(getpbc) # Property has no setter, so read-only
    rch = property(getrch) # Property has no setter, so read-only
    riv = property(getriv) # Property has no setter, so read-only
    wel = property(getwel) # Property has no setter, so read-only'''
    nrow_ncol_nlay_nper = property(get_nrow_ncol_nlay_nper) # Property has no setter, so read-only
    def set_name(self, value):
        # Overrides basemodel's setter for name property
        basemodel.set_name(self, value)

        for i in range(len(self.glo.extension)):
            self.glo.file_name[i] = self.name + '.' + self.glo.extension[i]

        for i in range(len(self.lst.extension)):
            self.lst.file_name[i] = self.name + '.' + self.lst.extension[i]
    name = property(basemodel.get_name, set_name) # Property must be redeclared to override basemodels setter method
    def write_name_file(self):
        fn_path = os.path.join(self.model_ws,self.namefile)
        f_nam = open(fn_path, 'w')
        f_nam.write('%s\n' % (self.heading) )
        if self.version == 'mf2k':
            f_nam.write('%s\t%3i\t%s\n' % (self.glo.name[0], self.glo.unit_number[0], self.glo.file_name[0]))
        f_nam.write('%s\t%3i\t%s\n' % (self.lst.name[0], self.lst.unit_number[0], self.lst.file_name[0]))
        f_nam.write('%s' % self.get_name_file_entries())
        f_nam.close()
